"missing" packages
------------------

    MYPACKAGES='vim htop rsync git tmux mosh'
    pacman -Syu $MYPACKAGES 


Install Arch Linux
===================

as root:

    # inet?
    ping nts.is

    # hdd
    cfdisk /dev/sda # new, primary, bootable, write
    mkfs.ext4 -L MANODE /dev/sda1
    mount /dev/sda1 /mnt

    # install minimal system
    pacstrap -i /mnt pacman systemd ip vim p git openssh nodejs

    # generate fstab (label-based, in case virthost messes with our /dev)
    genfstab -L -p /mnt >> /mnt/etc/fstab
    # check it out
    vi /mnt/etc/fstab

    # chroot #########################
    arch-chroot /mnt

    # lang
    echo 'en_US.UTF-8 UTF-8' > /etc/locale.gen
    locale-gen
    echo 'LANG=en_US.UTF-8' > /etc/locale.conf
    export LANG=en_US.UTF-8

    # time
    ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime
    hwclock --systohc --utc

    # kernel modules for virt ???
    echo '' > /etc/modules-load.d/virt.conf

    # hostname
    echo 'ma-node' > /etc/hostname

    # net
    ip l # get name of interface
    systemctl enable dhcpcd@eth0.service


Resize partitions (Raspberry Pi)
================================

> from [arch forum](http://archlinuxarm.org/forum/viewtopic.php?f=31&t=3119#p18160)

1. `fdisk /dev/mmcblk0`

2. Delete the second partition /dev/mmcblk0p2
    * `d`
    * `2`

3. Create a new primary partition and use default sizes prompted. This will then create a partiton that fills the disk
    * `n`
    * `p`
    * `2`
    * `<enter>`
    * `<enter>`

4. Save and exit fdisk: `w`

5. Now reboot.

6. Once rebooted: `resize2fs /dev/mmcblk0p2`



node.js with systemd
====================

install and autostart haibu

    npm install haiku coffee

    vim /etc/system/system/manode.service
    [Service]
    ExecStart=/usr/bin/node /home/node/manode.js
    Restart=always
    StandardOutput=syslog
    SyslogIdentifier=manode
    Environment=NODE_ENV=production
    [Install]
    WantedBy=multi-user.target

    systemctl enable manode.service

SAMBA
=====

install [samba](https://wiki.archlinux.org/index.php/Samba)  

    pacman -Syu samba

    MYUSER=mfa
    useradd -p penis -d /home/$MYUSER $MYUSER
    usermod -a -G samba $MYUSER

    # the default config already enables user home shares
    cp /etc/samba/smb.conf.default /etc/samba/smb.conf 

    # start it
    systemctl enable smbd nmbd
    systemctl start smbd nmbd
    systemctl status nmbd smbd


    
use [webmin web admin interface](https://wiki.archlinux.org/index.php/Webmin)


    pacman -Syu webmin
    vim /etc/webmin/miniserv.conf
    # include allowed IPs in allow=127.0.0.1 192.168.1.yourIP any.other.ip.addr
    # or tunnel from your virsh-wrapper
=============

A wrapper to use libvirt-tools in a multi user environment

##Usage

###Users
* must be members of a specific group (e. g. vmguests)
* create a directory named virsh with subdirectories log and history
* for every virtual machine (domain) a subdirectory should be created, naming convention: dom-<domain name>
* change group to vmguests for virsh and all subdirectories and grant read and write permissions to the group
* create a user named wrapper, also a member of vmguests and allow this user to sudo the script
 * wrapper ALL=NOPASSWD=/path/to/virsh_wrapper.sh
* in a directory the user creates files named by the action
 * for simple commands you only need to touch a file (e.g. start)
 * the content of a file is used as parameter, except domain name
* files are processed in descending order of last change time (first in, first out)
 
###System
* a cronjob runs every x minutes and loops users and directories
* in case of errors a mail is sent to root and the user

##Ressources
* virsh manpage: http://sancho.ccd.uniroma2.it/cgi-bin/man/man2html?virsh+1
* libvirt docs: http://libvirt.org/deployment.html

---

# New Structure (more general)

(WIP)

- namensideen:
    - `wirt` - **w**eimarnetz-v**ir**tualisierungs **t**ool
    - `mutti` - **m**ulti **u**ser/**t**enant **t**erminal **i**ntegration

## API

how it works?
- file-based: users on host write to their own config files
- pull-based: manager tool reads user's config and acts on it

config:
- endpoint: `~/virsh/` (folder in user's `$HOME directory`)

### fs example old:

    ~/virsh
    ├── dom-mymachine
    │   ├── start       # command, empty file
    │   ├── stop        # command, emptyfile
    │   ├── destroy     # command, emptyfile
    │   └── autostart   # command, empty file to enable; file content `--disable` to disable
    ├── history
    │   ├── 18_Feb_13_14.12-dom-mymachine-destroy
    │   └── 18_Feb_13_14.13-dom-mymachine-start
    └── log
        ├── 18_Feb_13_14.12-ma-dom-mymachine-destroy.log
        └── 18_Feb_13_14.13-ma-dom-mymachine-start.log


### fs example new 1:

    ~/wirt
    │
    ├── api
    │   ├── domain
    │   │   └── mykiste
    │   │       └── settings.json       # { "knoten": 178, "exthost": "kiste.in.weimarnetz.de" }
    │   └── vm
    │       └── mymachine
    │           ├── settings.json       # { "autostart": true }
    │           ├── status.json         # { "ok": true }
    │           ├── destroy             # command file [user +w, host +r]
    │           ├── start               # command file
    │           └── stop                # command file
    │
    └── logs
        ├── domain
        │   └── kiste.in.weimarnetz.log
        ├── history.log
        └── vm
            ├── mymachine.log           # a logfile for each vm
            └── mymachine.log.1.tgz     # [host +w, user +r]

### fs example new 2:

this could be even more split up if we find a reason.  
for example, it would be nice to seperate on a root level between user-writable and readable files.  
i.e. `logs` is read-only (since the host writes there).
`/api/vm/mymachine/.` has both commands and status.

    ~/wirt
    │
    ├── service                 # SERVICES (user can "send" commands to)
    │   │ 
    │   └── vm                  # vm resources
    │       └── mymachine       # example: mymachine
    │           ├── config      # settings.json to change
    │           ├── destroy     # empty
    │           ├── start       # empty
    │           └── stop        # empty
    │
    ├── info                    # INFO [host +w, user +r]
    │   ├── domain
    │   │   └── mykiste
    │   │       └── settings.json
    │   └── vm
    │       └── mymachine
    │           ├── settings.json
    │           └── status.json
    │
    └── logs                    # info [host +w, user +r]
        ├── domain
        │   └── kiste.in.weimarnetz.log
        ├── history.log
        └── vm
            ├── mymachine.log
            └── mymachine.log.1.tgz

in this version `/logs` and `/info` are to be written by the host and read by user, `/command` is the other way around (better name for `command` would be nice).


### Security

- security/rights management is all handled via unix user&group permissions
- authentication: not integrated in tool (since it's handled by OS)

### Resources/Services

from an api perspective, the supported *services* are **resources**.
for now, only virtual machines are supported.

### Implementation

- user can use cli tool (`wirt-cli`)
- this tool can also do admin function (when the user runningn it has the rights)
- current: in the backend, a shell script reads and acts (via cron)
- new: same, but more modular
    - either `virsh-wrapper` stays monolithic and gets js helper scripts
    - or the main script is js and the `virsh-wrapper` gets more split up in commandsside: ssh -N -L 1000/localhost/1000 root@alarmpi
    systemctl start webmin


go <http://alarmpi:10000>; <http://alarmpi:10000/samba/>


# Full-Disk-Encryption

<https://wiki.archlinux.org/index.php/Dm-crypt_with_LUKS#Prepare_hard_drive_for_Arch_Install_Scripts>

    # create a dm-crypt/LUKS blockdevice for the crypted root
    cryptsetup -y -v luksFormat /dev/sdaX
    
    # open it
    cryptsetup luksOpen /dev/sdaX cryptroot
    
    # format it
    mkfs -t ext4 /dev/mapper/cryptroot
    
    # mount it
    mount -t ext4 /dev/mapper/cryptroot /mnt
    
- continue normal install (`pacstrap`)
- **mkinitcpio**
    vim /etc/mkinitcpio.conf
    # this:
    HOOKS="base udev autodetect modconf block keyboard encrypt filesystems fsck"
    MODULES="virtio virtio_blk virtio_pci virtio_net dm_mod ext4"
- **GRUB**
    vim /etc/default/grub
    GRUB_CMDLINE_LINUX="cryptdevice=/dev/vda2:cryptroot"
- 