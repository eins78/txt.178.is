"missing" packages
------------------

    MYPACKAGES='vim htop rsync git tmux mosh'
    pacman -Syu $MYPACKAGES 


Install Arch Linux
===================

as root:

    # inet?
    ping nts.is

    # hdd
    cfdisk /dev/sda # new, primary, bootable, write
    mkfs.ext4 -L MANODE /dev/sda1
    mount /dev/sda1 /mnt

    # install minimal system
    pacstrap -i /mnt pacman systemd ip vim p git openssh nodejs

    # generate fstab (label-based, in case virthost messes with our /dev)
    genfstab -L -p /mnt >> /mnt/etc/fstab
    # check it out
    vi /mnt/etc/fstab

    # chroot #########################
    arch-chroot /mnt

    # lang
    echo 'en_US.UTF-8 UTF-8' > /etc/locale.gen
    locale-gen
    echo 'LANG=en_US.UTF-8' > /etc/locale.conf
    export LANG=en_US.UTF-8

    # time
    ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime
    hwclock --systohc --utc

    # kernel modules for virt ???
    echo '' > /etc/modules-load.d/virt.conf

    # hostname
    echo 'ma-node' > /etc/hostname

    # net
    ip l # get name of interface
    systemctl enable dhcpcd@eth0.service


Resize partitions (Raspberry Pi)
================================

> from [arch forum](http://archlinuxarm.org/forum/viewtopic.php?f=31&t=3119#p18160)

1. `fdisk /dev/mmcblk0`

2. Delete the second partition /dev/mmcblk0p2
    * `d`
    * `2`

3. Create a new primary partition and use default sizes prompted. This will then create a partiton that fills the disk
    * `n`
    * `p`
    * `2`
    * `<enter>`
    * `<enter>`

4. Save and exit fdisk: `w`

5. Now reboot.

6. Once rebooted: `resize2fs /dev/mmcblk0p2`



node.js with systemd
====================

install and autostart haibu

    npm install haiku coffee

    vim /etc/systemd/system/manode.service
    [Service]
    ExecStart=/usr/bin/node /home/node/manode.js
    Restart=always
    StandardOutput=syslog
    SyslogIdentifier=manode
    Environment=NODE_ENV=production
    [Install]
    WantedBy=multi-user.target

    systemctl enable manode.service

SAMBA
=====

install [samba](https://wiki.archlinux.org/index.php/Samba)  

    pacman -Syu samba

    MYUSER=mfa
    useradd -p penis -d /home/$MYUSER $MYUSER
    usermod -a -G samba $MYUSER

    # the default config already enables user home shares
    cp /etc/samba/smb.conf.default /etc/samba/smb.conf 

    # start it
    systemctl enable smbd nmbd
    systemctl start smbd nmbd
    systemctl status nmbd smbd


    
use [webmin web admin interface](https://wiki.archlinux.org/index.php/Webmin)


    pacman -Syu webmin
    vim /etc/webmin/miniserv.conf
    # include allowed IPs in allow=127.0.0.1 192.168.1.yourIP any.other.ip.addr
    # or tunnel from your virsh-wrapper

go <http://alarmpi:10000>; <http://alarmpi:10000/samba/>


# Full-Disk-Encryption

<https://wiki.archlinux.org/index.php/Dm-crypt_with_LUKS#Prepare_hard_drive_for_Arch_Install_Scripts>

    # create a dm-crypt/LUKS blockdevice for the crypted root
    cryptsetup -y -v luksFormat /dev/sdaX
    
    # open it
    cryptsetup luksOpen /dev/sdaX cryptroot
    
    # format it
    mkfs -t ext4 /dev/mapper/cryptroot
    
    # mount it
    mount -t ext4 /dev/mapper/cryptroot /mnt
    
- continue normal install (`pacstrap`)
- **mkinitcpio**
    vim /etc/mkinitcpio.conf
    # this:
    HOOKS="base udev autodetect modconf block keyboard encrypt filesystems fsck"
    MODULES="virtio virtio_blk virtio_pci virtio_net dm_mod ext4"
- **GRUB**
    vim /etc/default/grub
    GRUB_CMDLINE_LINUX="cryptdevice=/dev/vda2:cryptroot"

# authbind

tl;dr: 

    mkdir -p /etc/authbind/byport/
    touch /etc/authbind/byport/80
    chmod 441 /etc/authbind/byport/80
    chown js:js /etc/authbind/byport/80
    
---

    ACCESS CONTROL
       Access  to low numbered ports is controlled by permissions and contents
       of files in a configuration area, /etc/authbind.

       Firstly,  /etc/authbind/byport/port  is  tested.   If  this   file   is
       accessible  for  execution to the calling user, according to access(2),
       then binding to the port is authorised.  If the file can be seen not to
       exist  (the  existence check returns ENOENT) then further tests will be
       used to find authorisation; otherwise, binding is not  authorised,  and
       the bind call will return with the errno value from the access(2) call,
       usually EACCES (Permission denied).

       Secondly,   if   that   test   fails    to    resolve    the    matter,
       /etc/authbind/byaddr/addr:port  is tested, in the same manner as above.
